module Test.Parse.Expression exposing ( tests )

import Expect exposing (Expectation)
import Test exposing (Test, describe, test, fuzz)
import Fuzz exposing (Fuzzer)
import Parser.Advanced as Parser
import Parse.Expression as PE
import Parse.Number as Number
import AST.Source as AST
import SourcePosition


tests : Test
tests =
    describe "Parse.Expression"
        [ describe "Primitives"
            [ test "Int" <| \_ ->
                Parser.run PE.parser "5"
                    |> expectExpression (AST.NumberLiteral (Number.Integer 5))
            , test "Negative Int" <| \_ ->
                Parser.run PE.parser "-15"
                    |> expectExpression
                        (AST.Negate
                            { start = { row = 1, col = 2 }
                            , end = { row = 1, col = 4 }
                            , value = AST.NumberLiteral (Number.Integer 15)
                            }
                        )
            , test "Float" <| \_ ->
                Parser.run PE.parser "3.14"
                    |> expectExpression (AST.NumberLiteral (Number.FloatingPoint 3.14))
            , test "Hex" <| \_ ->
                Parser.run PE.parser "0xDE"
                    |> expectExpression (AST.NumberLiteral (Number.Hex 0xDE))
            , test "Char" <| \_ ->
                Parser.run PE.parser "'z'"
                    |> expectExpression (AST.CharLiteral 'z')
            , test "String" <| \_ ->
                Parser.run PE.parser "\"test\""
                    |> expectExpression (AST.StringLiteral "test")
            , test "Ctor" <| \_ ->
                Parser.run PE.parser "True"
                    |> expectExpression (AST.Var { name = "True", varType = AST.CapVar })
            , test "var name" <| \_ ->
                Parser.run PE.parser "myvar"
                    |> expectExpression (AST.Var { name = "myvar", varType = AST.LowVar })
            , test "accessor" <| \_ ->
                Parser.run PE.parser ".field"
                    |> expectExpression (AST.Accessor "field")
            , test "wildcard error" <| \_ ->
                Parser.run PE.parser "_unused"
                    |> expectErr PE.WildcardAttempt
            , test "nested accessors" <| \_ ->
                Parser.run PE.parser "nested.accessor.expression"
                    |> expectExpression
                        (AST.Access
                            { expression =
                                { start = { row = 1, col = 8}
                                , end = { row = 1, col = 16}
                                , value =
                                    AST.Access
                                        { expression =
                                            { start = { row = 1, col = 1 }
                                            , end = { row = 1, col = 7 }
                                            , value = AST.Var { name = "nested", varType = AST.LowVar }
                                            }
                                        , accessor = "accessor"
                                        }
                                }
                            , accessor = "expression"
                            }
                        )
            ]
        ]


expectExpression : a -> Result (Array (Parser.DeadEnd c e)) (SourcePosition.Located a) -> Expectation
expectExpression expected result =
    when result is
        Err err ->
            Expect.fail (Debug.toString err)

        Ok { value } ->
            Expect.equal expected value


expectErr : PE.Error -> Result (Array (Parser.DeadEnd c PE.Error)) a -> Expectation
expectErr expected result =
    when result is
        Ok _ ->
            Expect.fail "Expected error"

        Err problems ->
            when Array.first problems is
                Just firstProblem ->
                    Expect.equal expected firstProblem.problem

                Nothing ->
                    Expect.fail "Failed, but with no problems..."
