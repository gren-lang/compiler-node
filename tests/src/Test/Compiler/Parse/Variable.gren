module Test.Compiler.Parse.Variable exposing ( tests )

import Expect exposing (Expectation)
import Test exposing (Test, describe, test)
import String.Parser.Advanced as Parser
import Compiler.Parse.Variable as PV
import Compiler.Parse.Context as Context
import Set


tests : Test
tests =
    describe "Parse.Variable"
        [ describe "Lower case"
            [ test "Simple case" <| \_ ->
                Parser.run PV.lowerCase Context.empty "myvar"
                    |> Expect.equal (Ok "myvar")
            , test "unicode" <| \_ ->
                Parser.run PV.lowerCase Context.empty "Ã¥berg albert"
                    |> Expect.equal (Ok "Ã¥berg")
            , test "underscore" <| \_ ->
                Parser.run PV.lowerCase Context.empty "my_var"
                    |> Expect.equal (Ok "my_var")
            , test "with unicode, upper case, digits and underscore" <| \_ ->
                Parser.run PV.lowerCase Context.empty "miN_1_Ã˜se"
                    |> Expect.equal (Ok "miN_1_Ã˜se")
            , test "no emojis" <| \_ ->
                Parser.run PV.lowerCase Context.empty "heyðŸ«µ"
                    |> Expect.equal (Ok "hey")
            , test "cannot start with digit" <| \_ ->
                Parser.run PV.lowerCase Context.empty "1month"
                    |> expectErr PV.InvalidCharacter
            , test "cannot start with upper case" <| \_ ->
                Parser.run PV.lowerCase Context.empty "Month"
                    |> expectErr PV.InvalidCharacter
            , test "refuses to parse reserved words" <| \_ ->
                Set.toArray PV.reservedWords
                    |> Array.map (Parser.run PV.lowerCase Context.empty)
                    |> Result.firstOk
                    |> Expect.equal Nothing
            ]
        , describe "Upper case"
            [ test "Simple case" <| \_ ->
                Parser.run PV.upperCase Context.empty "Myvar"
                    |> Expect.equal (Ok "Myvar")
            , test "unicode" <| \_ ->
                Parser.run PV.upperCase Context.empty "Ã…berg albert"
                    |> Expect.equal (Ok "Ã…berg")
            , test "underscore" <| \_ ->
                Parser.run PV.upperCase Context.empty "My_var"
                    |> Expect.equal (Ok "My_var")
            , test "with unicode, upper case, digits and underscore" <| \_ ->
                Parser.run PV.upperCase Context.empty "MiN_1_Ã˜se"
                    |> Expect.equal (Ok "MiN_1_Ã˜se")
            , test "no emojis" <| \_ ->
                Parser.run PV.upperCase Context.empty "HeyðŸ«µ"
                    |> Expect.equal (Ok "Hey")
            , test "cannot start with digit" <| \_ ->
                Parser.run PV.upperCase Context.empty "1month"
                    |> expectErr PV.InvalidCharacter
            , test "cannot start with lower case" <| \_ ->
                Parser.run PV.upperCase Context.empty "month"
                    |> expectErr PV.InvalidCharacter
            ]
        , describe "Possibly qualified upper"
            [ test "Unqualified" <| \_ ->
                Parser.run PV.foreignUpper Context.empty "Upper"
                    |> Expect.equal (Ok (PV.Unqualified "Upper"))
            , test "Qualified" <| \_ ->
                Parser.run PV.foreignUpper Context.empty "My.Upper"
                    |> Expect.equal (Ok (PV.Qualified { module_ = "My", name = "Upper" }))
            , test "Qualified (2)" <| \_ ->
                Parser.run PV.foreignUpper Context.empty "My.Nested.Upper"
                    |> Expect.equal (Ok (PV.Qualified { module_ = "My.Nested", name = "Upper" }))
            ]
        ]


expectErr : PV.Error -> Result (Array (Parser.DeadEnd c PV.Error)) String -> Expectation
expectErr expected result =
    when result is
        Ok _ ->
            Expect.fail "Expected error"

        Err problems ->
            when Array.first problems is
                Just firstProblem ->
                    Expect.equal expected firstProblem.problem

                Nothing ->
                    Expect.fail "Failed, but with no problems..."
