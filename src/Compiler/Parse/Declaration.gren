module Compiler.Parse.Declaration exposing
    ( Declaration
    , DeclarationValue (..)
    , Error (..)
    , parser
    , docParser
    )


import String.Parser.Advanced as Parser exposing (Parser)
import Compiler.Ast.Source as AST
import SourcePosition
import Compiler.Parse.Space as Space
import Compiler.Parse.Variable as Variable
import Compiler.Parse.Pattern as Pattern
import Compiler.Parse.Type as Type
import Compiler.Parse.Expression as Expr
import Compiler.Parse.Context exposing (Context)


type alias Declaration =
    { docs : Maybe (SourcePosition.Located String)
    , value : DeclarationValue
    }


type DeclarationValue
    = Alias AST.Alias
    | Union AST.Union
    | Value AST.Value
    | Port AST.Port


type Error
    = ExpectedKeyword String
    | ExpectedChar Char
    | VariableError Variable.Error
    | TypeError Type.Error
    | ExprError Expr.Error
    | SpaceError Space.Error


spaceParser : Parser Context Error {}
spaceParser =
    Parser.mapError SpaceError Space.parser


parser : Parser Context Error Declaration
parser =
    Parser.succeed
        (\docs value ->
            { docs = docs
            , value = value
            }
        )
        |> Parser.keep (docParser ExpectedKeyword)
        |> Parser.keep
            (Parser.oneOf
                [ typeParser
                , portParser
                , Expr.letDefNamedParser
                    |> Parser.mapError ExprError
                    |> Parser.map
                        (\def ->
                            Value
                                { name = def.value.name
                                , signature = def.value.typeSignature
                                , args = def.value.args
                                , body = def.value.body
                                }
                        )
                ]
            )


docParser : (String -> err) -> Parser Context err (Maybe (SourcePosition.Located String))
docParser toErr =
    let
        spaceErr : Space.Error -> err
        spaceErr spaceError =
            when spaceError is
                Space.ExpectedLineComment ->
                    toErr "expected line comment"

                Space.InvalidWhiteSpace ->
                    toErr "expected white space character"
    in
    Parser.oneOf
        [ Parser.succeed
            (\docStart doc docEnd ->
                Just <|
                    SourcePosition.at docStart docEnd doc
            )
            |> Parser.keep Parser.getPosition
            |> Parser.skip (Parser.token "{-|" (toErr "{-|"))
            |> Parser.skip (Parser.mapError spaceErr Space.parser)
            |> Parser.keep
                (Parser.chompUntil "-}" (toErr "-}")
                    |> Parser.getChompedString
                    |> Parser.map String.trim
                )
            |> Parser.skip (Parser.token "-}" (toErr "-}"))
            |> Parser.keep Parser.getPosition
            |> Parser.skip (Parser.mapError spaceErr Space.parser)
        , Parser.succeed Nothing
        ]


typeParser : Parser Context Error DeclarationValue
typeParser =
    Parser.succeed identity
        |> Parser.skip (Parser.token "type" (ExpectedKeyword "type"))
        |> Parser.skip spaceParser
        |> Parser.keep (Parser.oneOf [ aliasParser, unionParser ])


aliasParser : Parser Context Error DeclarationValue
aliasParser =
    Parser.succeed
        (\nameStart name nameEnd vars tipe ->
            Alias
                { name = SourcePosition.at nameStart nameEnd name
                , vars = vars
                , type_ = tipe
                }
        )
        |> Parser.skip (Parser.token "alias" (ExpectedKeyword "alias"))
        |> Parser.skip spaceParser
        |> Parser.keep Parser.getPosition
        |> Parser.keep (Parser.mapError VariableError Variable.upperCase)
        |> Parser.keep Parser.getPosition
        |> Parser.skip spaceParser
        |> Parser.keep (Parser.loop [] typeArgLoopParser)
        |> Parser.skip spaceParser
        |> Parser.keep (Parser.mapError TypeError Type.expression)


typeArgLoopParser : Array (SourcePosition.Located String) -> Parser Context Error (Parser.Step (Array (SourcePosition.Located String)) (Array (SourcePosition.Located String)))
typeArgLoopParser vars =
    Parser.oneOf
        [ Parser.succeed (Parser.Done vars)
            |> Parser.skip (Parser.chompChar '=' (ExpectedChar '='))
        , Parser.succeed
            (\varStart var varEnd ->
                Parser.Loop <|
                    Array.pushLast (SourcePosition.at varStart varEnd var) vars
            )
            |> Parser.keep Parser.getPosition
            |> Parser.keep (Parser.mapError VariableError Variable.lowerCase)
            |> Parser.keep Parser.getPosition
            |> Parser.skip spaceParser
        ]


unionParser : Parser Context Error DeclarationValue
unionParser =
    Parser.succeed
        (\nameStart name nameEnd vars variants ->
            Union
                { name = SourcePosition.at nameStart nameEnd name
                , vars = vars
                , variants = variants
                }
        )
        |> Parser.keep Parser.getPosition
        |> Parser.keep (Parser.mapError VariableError Variable.upperCase)
        |> Parser.keep Parser.getPosition
        |> Parser.skip spaceParser
        |> Parser.keep (Parser.loop [] typeArgLoopParser)
        |> Parser.skip spaceParser
        |> Parser.keep
            (variantParser
                |> Parser.andThen
                    (\firstVariant ->
                        (Parser.loop [ firstVariant ] variantLoopParser)
                    )
            )


variantParser : Parser Context Error (SourcePosition.Located AST.UnionVariant)
variantParser =
    Parser.succeed
        (\nameStart name nameEnd payload ->
            let
                variantEnd =
                    payload
                        |> Maybe.map .end
                        |> Maybe.withDefault nameEnd
            in
            SourcePosition.at
                nameStart
                variantEnd
                { name = SourcePosition.at nameStart nameEnd name
                , payload = payload
                }
        )
        |> Parser.keep Parser.getPosition
        |> Parser.keep (Parser.mapError VariableError Variable.upperCase)
        |> Parser.keep Parser.getPosition
        |> Parser.skip spaceParser
        |> Parser.keep
            (Parser.oneOf
                [ Parser.succeed Just
                    |> Parser.keep (Parser.mapError TypeError Type.expression)
                , Parser.succeed Nothing
                ]
            )


variantLoopParser : Array (SourcePosition.Located AST.UnionVariant) -> Parser Context Error (Parser.Step (Array (SourcePosition.Located AST.UnionVariant)) (Array (SourcePosition.Located AST.UnionVariant)))
variantLoopParser variants =
    Parser.oneOf
        [ Parser.succeed
            (\variant ->
                Parser.Loop <|
                    Array.pushLast variant variants
            )
            |> Parser.skip (Parser.chompChar '|' (ExpectedChar '|'))
            |> Parser.skip spaceParser
            |> Parser.keep variantParser
        , Parser.succeed (Parser.Done variants)
        ]


portParser : Parser Context Error DeclarationValue
portParser =
    Parser.succeed
        (\nameStart name nameEnd tipe ->
            Port
                { name = SourcePosition.at nameStart nameEnd name
                , signature = tipe
                }
        )
        |> Parser.skip (Parser.token "port" (ExpectedKeyword "port"))
        |> Parser.skip spaceParser
        |> Parser.keep Parser.getPosition
        |> Parser.keep (Parser.mapError VariableError Variable.lowerCase)
        |> Parser.keep Parser.getPosition
        |> Parser.skip spaceParser
        |> Parser.skip (Parser.chompChar ':' (ExpectedChar ':'))
        |> Parser.skip spaceParser
        |> Parser.keep (Parser.mapError TypeError Type.expression)
