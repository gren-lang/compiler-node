module Compiler.Backend exposing 
    ( version
    --
    , Command(..)
    , InitFlags
    , ReplFlags
    , MakeFlags
    , MakeOutput(..)
    , DocsFlags
    , DocsOutput(..)
    , DiffArgs(..)
    , encodeCommand
    , run
    --
    , UnsupportedPlatform(..)
    , downloadUrl
    , download
    , cachePath
    , isCached
    )


{-| Functions for working with the Haskell-based Gren compiler.

@docs version

@docs UnsupportedPlatform, downloadUrl, download, cachePath, isCached

@docs Command, InitFlags, ReplFlags, MakeFlags, MakeOutput, DocsFlags, DocsOutput, DiffArgs, Platform, encodeCommand, run

-}


import Node
import FileSystem
import FileSystem.Path as Path exposing (Path)
import Compiler.PackageName as PackageName exposing (PackageName)
import Compiler.Platform as Platform exposing (Platform)
import Compiler.Outline as Outline exposing (Outline)
import SemanticVersion exposing (SemanticVersion)
import ChildProcess exposing (Shell(..))
import Json.Encode as Json
import Dict exposing (Dict)
import Task exposing (Task)
import Bytes exposing (Bytes)
import HttpClient
import Process


{-| Version of the compiler blob. This might not match the version of the Gren compiler as a whole,
as the Haskell- and Gren-parts are versioned seperatly.
-}
version : String
version =
    "0.5.2"


-- Binary


{-| Type used to signal that the given platform isn't supported. Meaning that there doesn't exist
a pre-built compiler blob.
-}
type UnsupportedPlatform
    = UnsupportedPlatform


{-| Construct a URL from which you can download a compiler blob compatible with the given
platform and cpu architecture.
-}
downloadUrl : Node.Platform -> Node.CpuArchitecture -> Result UnsupportedPlatform String
downloadUrl platform cpuArch =
    let
        maybeFilename =
            when { platform = platform, cpuArch = cpuArch } is
                { platform = Node.Win32, cpuArch = Node.X64 } ->
                    Just "gren.exe"
                
                { platform = Node.Darwin, cpuArch = Node.X64 } ->
                    Just "gren_mac"
                
                { platform = Node.Darwin, cpuArch = Node.Arm64 } ->
                    Just "gren_mac_aarch64"
                
                { platform = Node.Linux, cpuArch = Node.X64 } ->
                    Just "gren_linux"

                _ ->
                    Nothing
    in
    when maybeFilename is
        Just filename ->
            Ok <|
                String.join "/"
                    [ "https://github.com/gren-lang/compiler/releases/download"
                    , "blob-" ++ version
                    , filename
                    ]

        Nothing ->
            Err UnsupportedPlatform


{-| Downlod the compiler blob.
-}
download : HttpClient.Permission -> String -> Task (HttpClient.Error Bytes) (HttpClient.Response Bytes)
download permission url =
    HttpClient.get url
        |> HttpClient.expectBytes
        |> HttpClient.send permission


{-| Construct a `Path` where we'd expect to find the compiler blob if it has been downloaded
previously.
-}
cachePath : Node.Platform -> Dict String String -> Path -> Path
cachePath platform envVars homeDir =
    let
        startPath =
            when platform is
                Node.Win32 ->
                    envVars
                        |> Dict.get "LOCALAPPDATA"
                        |> Maybe.map Path.fromWin32String
                        |> Maybe.withDefault (
                            "AppData/Local"
                                |> Path.fromPosixString
                                |> Path.prepend homeDir
                            )

                Node.Darwin ->
                    "Library/Caches"
                        |> Path.fromPosixString
                        |> Path.prepend homeDir

                _ ->
                    envVars
                        |> Dict.get "XDG_CACHE_HOME"
                        |> Maybe.map Path.fromPosixString
                        |> Maybe.withDefault (Path.append (Path.fromPosixString ".cache") homeDir)

        filename =
            when platform is
                Node.Win32 ->
                    "gren.exe"

                _ ->
                    "gren"
        
        endPath =
            [ "gren"
            , version
            , "bin"
            , filename
            ]
                |> String.join "/"
                |> Path.fromPosixString
    in
    Path.prepend startPath endPath


{-| Checks if the compiler blob exist on this system.
-}
isCached : FileSystem.Permission -> Node.Platform -> Dict String String -> Path -> Task x Bool
isCached permission platform envVars homeDir =
    cachePath platform envVars homeDir
        |> FileSystem.checkAccess permission []
        |> Task.map (\_ -> True)
        |> Task.onError (\_ -> Task.succeed False)


-- Compiler Commands


{-| Commands supported by the compiler blob.

* `Init`: generate a gren.json and src directory in the current directory.
* `Repl`: run a REPL.
* `Make`: compile a project
* `Docs`: generate a docs.json file
* `PackageInstall`: install dependencies
* `PackageUninstall`: remove a dependency
* `PackageOutdated`: get a list of outdated dependencies
* `PackageValide`: check if this package is ready to be deployed
* `PackageBump`: bump package version to next compatible semantic version
* `PackageDiff`: calculate the API-difference between this package and another version.
-}
type Command
    = Init InitFlags
    | Repl ReplFlags
    | Make MakeFlags
    | Docs DocsFlags
    | PackageInstall (Maybe PackageName)
    | PackageUninstall PackageName
    | PackageOutdated
    | PackageValidate
    | PackageBump
    | PackageDiff DiffArgs


{-|-}
type alias InitFlags =
    { package : Bool
    , platform : Platform
    }


{-|-}
type alias ReplFlags =
    { interpreter : Maybe String
    }


{-|-}
type alias MakeFlags =
    { optimize : Bool
    , sourcemaps : Bool
    , output : Maybe MakeOutput
    , report : Maybe {}
    , projectPath : Path
    , entryPoints : Array Path
    , outline : Outline
    , rootSources : Dict String String
    , dependencies : Dict String { outline : Outline, sources : Dict String String }
    }


{-|-}
type MakeOutput
    = StdOut
    | DevNull
    | Html String
    | Js String
    | Exe String


{-|-}
type alias DocsFlags =
    { output : Maybe DocsOutput
    , report : Maybe {}
    }


{-|-}
type DocsOutput
    = DocsStdOut
    | DocsDevNull
    | DocsJson String


{-|-}
type DiffArgs
    = DiffLatest
    | DiffVersion SemanticVersion
    | DiffRange { lower : SemanticVersion, upper : SemanticVersion }
    | DiffGlobal { package : PackageName, lower : SemanticVersion, upper : SemanticVersion }


{-|-}
type alias RunOptions msg =
    { useColor : Bool
    , compilerPath : Path
    , pathToString : (Path -> String)
    , onInit : { processId : Process.Id, streams : Maybe ChildProcess.StreamIO } -> msg
    , onComplete : (Int -> msg)
    }


{-| Execute the compiler backend. The backend will write to stdout and stderr. There's currently no way
to redirect what is written to these streams.
-}
run : ChildProcess.Permission -> RunOptions msg -> Cmd msg
run permission options =
    let
        colorEnvVar =
            if options.useColor then
                Dict.singleton "FORCE_COLOR" "1"
            else
                Dict.singleton "NO_COLOR" "1"
    in
    ChildProcess.spawn 
        permission
        (options.pathToString options.compilerPath) 
        []
        { ( ChildProcess.defaultSpawnOptions options.onInit options.onComplete )
            | shell = NoShell
            , environmentVariables = 
                ChildProcess.MergeWithEnvironmentVariables colorEnvVar
        }


{-| Encode a backend command to JSON. This should be fed to the compiler backend upon
initialization.
-}
encodeCommand : { interactiveSession : Bool, pathToString : Path -> String } -> Command -> Bytes
encodeCommand options command =
    command
        |> commandEncoder options.interactiveSession options.pathToString
        |> Json.encode 0
        |> Bytes.fromString


commandEncoder : Bool -> (Path -> String) -> Command -> Json.Value
commandEncoder interactive pathToString command =
    when command is
        Init flags ->
            Json.object
                [ { key = "command", value = Json.string "init" }
                , { key = "interactive", value = Json.bool interactive }
                , { key = "package", value = Json.bool flags.package }
                , { key = "platform", value = Platform.toJson flags.platform }
                ]
        
        Repl flags ->
            Json.object
                [ { key = "command", value = Json.string "repl" }
                , { key = "intepreter" , value = maybeEncoder Json.string flags.interpreter }
                ]
        
        Make flags ->
            let
                depsToJson : { outline : Outline, sources : Dict String String } -> Json.Value
                depsToJson dep =
                    Json.object
                        [ { key = "outline", value = Outline.toJson dep.outline }
                        , { key = "sources", value = Json.dict identity Json.string dep.sources }
                        ]
            in
            Json.object
                [ { key = "command", value = Json.string "make" }
                , { key = "optimize", value = Json.bool flags.optimize }
                , { key = "sourcemaps", value = Json.bool flags.sourcemaps }
                , { key = "output", value = maybeEncoder makeOutputEncoder flags.output }
                , { key = "report-json", value = maybeToBool flags.report }
                , { key = "project-path", value = Json.string <| pathToString flags.projectPath }
                , { key = "entry-points", value = Json.array (Json.string << pathToString) flags.entryPoints }
                , { key = "project-outline", value = Outline.toJson flags.outline }
                , { key = "sources", value = Json.dict identity Json.string flags.rootSources }
                , { key = "dependencies", value = Json.dict identity depsToJson flags.dependencies }
                ]
        
        Docs flags ->
            Json.object
                [ { key = "command", value = Json.string "docs" }
                , { key = "output", value = maybeEncoder docsOutputEncoder flags.output }
                , { key = "report-json", value = maybeToBool flags.report }
                ]
        
        PackageInstall maybePackage ->
            Json.object
                [ { key = "command", value = Json.string "packageInstall" }
                , { key = "interactive", value = Json.bool interactive }
                , { key = "package", value = maybeEncoder PackageName.toJson maybePackage }
                ]
        
        PackageUninstall package ->
            Json.object
                [ { key = "command", value = Json.string "packageUninstall" }
                , { key = "interactive", value = Json.bool interactive }
                , { key = "package", value = PackageName.toJson package }
                ]
        
        PackageOutdated ->
            Json.object
                [ { key = "command", value = Json.string "packageOutdated" }
                ]
        
        PackageValidate ->
            Json.object
                [ { key = "command", value = Json.string "packageValidate" }
                ]
        
        PackageBump ->
            Json.object
                [ { key = "command", value = Json.string "packageBump" }
                , { key = "interactive", value = Json.bool interactive }
                ]
        
        PackageDiff args ->
            when args is
                DiffLatest ->
                    Json.object
                        [ { key = "command", value = Json.string "packageDiffLatest" }
                        ]
                
                DiffVersion ver ->
                    Json.object
                        [ { key = "command", value = Json.string "packageDiffVersion" }
                        , { key = "version", value = SemanticVersion.toJson ver }
                        ]
                
                DiffRange { lower = ver1, upper = ver2 } ->
                    Json.object
                        [ { key = "command", value = Json.string "packageDiffRange" }
                        , { key = "from", value = SemanticVersion.toJson ver1 }
                        , { key = "to", value = SemanticVersion.toJson ver2 }
                        ]
                
                DiffGlobal { package, lower = ver1, upper = ver2 } ->
                    Json.object
                        [ { key = "command", value = Json.string "packageDiffGlobal" }
                        , { key = "package", value = PackageName.toJson package }
                        , { key = "from", value = SemanticVersion.toJson ver1 }
                        , { key = "to", value = SemanticVersion.toJson ver2 }
                        ]


maybeEncoder : (a -> Json.Value) -> Maybe a -> Json.Value
maybeEncoder enc maybeVal =
    when maybeVal is
        Just val ->
            enc val

        Nothing ->
            Json.null


maybeToBool : Maybe a -> Json.Value
maybeToBool maybeVal =
    when maybeVal is
        Just val ->
            Json.bool True

        Nothing ->
            Json.bool False


makeOutputEncoder : MakeOutput -> Json.Value
makeOutputEncoder output =
    when output is
        StdOut -> 
            Json.object
                [ { key = "type", value = Json.string "stdout" }
                ]
        
        DevNull ->
            Json.object
                [ { key = "type", value = Json.string "null" }
                ]
        
        Html path ->
            Json.object
                [ { key = "type", value = Json.string "html" }
                , { key = "path", value = Json.string path }
                ]
        
        Js path ->
            Json.object
                [ { key = "type", value = Json.string "js" }
                , { key = "path", value = Json.string path }
                ]
        
        Exe path ->
            Json.object
                [ { key = "type", value = Json.string "exe" }
                , { key = "path", value = Json.string path }
                ]


docsOutputEncoder : DocsOutput -> Json.Value
docsOutputEncoder output =
    when output is
        DocsStdOut -> 
            Json.object
                [ { key = "type", value = Json.string "stdout" }
                ]
        
        DocsDevNull ->
            Json.object
                [ { key = "type", value = Json.string "null" }
                ]
        
        DocsJson path ->
            Json.object
                [ { key = "type", value = Json.string "json" }
                , { key = "path", value = Json.string path }
                ]
