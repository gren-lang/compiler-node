module Parse.Module exposing
    ( Error (..)
    , parser
    )


import Parser.Advanced as Parser exposing (Parser)
import AST.Source as AST
import SourcePosition
import Parse.Space as Space
import Parse.Variable as Variable
import Parse.Operator as Operator
import Parse.Declaration as Declaration


type Error
    = ExpectedKeyword String
    | ExpectedChar Char
    | VariableError Variable.Error
    | OperatorError Operator.Error


parser : Parser c Error AST.Module
parser =
    Parser.succeed
        (\name exports docs imports ->
            { name = name
            , exports = exports
            , docs = docs
            , imports = imports
            , values = []
            , unions = []
            , aliases = []
            , binops = []
            , effects = AST.NoEffects
            }
        )
        |> Parser.skip (Parser.token (Parser.Token { str = "module", expecting = ExpectedKeyword "module"}))
        |> Parser.skip Space.parser
        |> Parser.keep moduleNameParser
        |> Parser.skip Space.parser
        |> Parser.skip (Parser.token (Parser.Token { str = "exposing", expecting = ExpectedKeyword "exposing"}))
        |> Parser.skip Space.parser
        |> Parser.skip (Parser.chompIf (\c -> c == '(') (ExpectedChar '('))
        |> Parser.skip Space.parser
        |> Parser.keep
            (Parser.oneOf
                [ Parser.succeed AST.Open
                    |> Parser.skip (Parser.token (Parser.Token { str = "..", expecting = ExpectedKeyword ".."}))
                    |> Parser.skip Space.parser
                    |> Parser.skip (Parser.chompIf (\c -> c == ')') (ExpectedChar ')'))
                , Parser.succeed AST.Explicit
                    |> Parser.keep
                        (parseExposingValue
                            |> Parser.skip Space.parser
                            |> Parser.andThen
                                (\firstExposing ->
                                    Parser.loop [ firstExposing ] parseExposingArray
                                )
                        )
                ]
            )
        |> Parser.skip Space.parser
        |> Parser.keep (Declaration.docParser ExpectedKeyword)
        |> Parser.skip Space.parser
        |> Parser.keep (Parser.loop [] importLoopParser)


moduleNameParser : Parser c Error (SourcePosition.Located String)
moduleNameParser =
    SourcePosition.parser
        ( Variable.foreignUpper
            |> Parser.mapError VariableError
            |> Parser.map Variable.foreignVarToString
        )

    
parseExposingArray : Array AST.Exposed -> Parser c Error (Parser.Step (Array AST.Exposed) (Array AST.Exposed))
parseExposingArray exps =
    Parser.oneOf
        [ Parser.succeed (Parser.Done exps)
            |> Parser.skip (Parser.chompIf (\c -> c == ')') (ExpectedChar ')'))
        , Parser.succeed (\next -> Parser.Loop <| Array.pushLast next exps)
            |> Parser.skip (Parser.chompIf (\c -> c == ',') (ExpectedChar ','))
            |> Parser.skip Space.parser
            |> Parser.keep parseExposingValue
            |> Parser.skip Space.parser
        ]


parseExposingValue : Parser c Error AST.Exposed
parseExposingValue =
    Parser.oneOf
        [ Parser.succeed AST.ExposedLower
            |> Parser.keep
                (SourcePosition.parser Variable.lowerCase
                    |> Parser.mapError VariableError
                )
        , Parser.succeed (\name privacy -> AST.ExposedUpper { name = name, privacy = privacy })
            |> Parser.keep
                (SourcePosition.parser Variable.upperCase
                    |> Parser.mapError VariableError
                )
            |> Parser.skip Space.parser
            |> Parser.keep
                (Parser.oneOf
                    [ Parser.succeed AST.Public
                        |> Parser.skip (Parser.chompIf (\c -> c == '(') (ExpectedChar '('))
                        |> Parser.skip Space.parser
                        |> Parser.skip (Parser.token (Parser.Token { str = "..", expecting = ExpectedKeyword ".."}))
                        |> Parser.skip Space.parser
                        |> Parser.skip (Parser.chompIf (\c -> c == ')') (ExpectedChar ')'))
                    , Parser.succeed AST.Private
                    ]
                )
        , Parser.succeed AST.ExposedOperator
            |> Parser.skip (Parser.chompIf (\c -> c == '(') (ExpectedChar '('))
            |> Parser.keep
                (SourcePosition.parser Operator.parser
                    |> Parser.mapError OperatorError
                )
            |> Parser.skip (Parser.chompIf (\c -> c == ')') (ExpectedChar ')'))
        ]


importLoopParser
    : Array (SourcePosition.Located AST.Import)
    -> Parser c Error (Parser.Step (Array (SourcePosition.Located AST.Import)) (Array (SourcePosition.Located  AST.Import)))
importLoopParser imps =
    Parser.oneOf
        [ Parser.succeed
            (\moduleName ->
                Parser.Loop <|
                    Array.pushLast
                        ( SourcePosition.at
                            { moduleName.start | col = 1 }
                            moduleName.end
                            { module_ = moduleName
                            , alias = Nothing
                            , expose = AST.Explicit []
                            }
                        )
                        imps
            )
            |> Parser.skip (Parser.token (Parser.Token { str = "import", expecting = ExpectedKeyword "import"}))
            |> Parser.skip Space.parser
            |> Parser.keep moduleNameParser
            |> Parser.skip Space.parser
        , Parser.succeed (Parser.Done imps)
        ]
