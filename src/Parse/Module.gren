module Parse.Module exposing
    ( Error (..)
    , parser
    )


import Parser.Advanced as Parser exposing (Parser)
import AST.Source as AST
import SourcePosition
import Parse.Space as Space
import Parse.Variable as Variable
import Parse.Operator as Operator
import Parse.Declaration as Declaration


type Error
    = ExpectedKeyword String
    | ExpectedChar Char
    | VariableError Variable.Error
    | OperatorError Operator.Error


parser : Parser c Error AST.Module
parser =
    Parser.succeed
        (\name exports docs imports ->
            { name = name
            , exports = exports
            , docs = docs
            , imports = imports
            , values = []
            , unions = []
            , aliases = []
            , binops = []
            , effects = AST.NoEffects
            }
        )
        |> Parser.skip (Parser.token (Parser.Token { str = "module", expecting = ExpectedKeyword "module"}))
        |> Parser.skip Space.parser
        |> Parser.keep moduleNameParser
        |> Parser.skip Space.parser
        |> Parser.keep parseExposingStatement
        |> Parser.skip Space.parser
        |> Parser.keep (Declaration.docParser ExpectedKeyword)
        |> Parser.skip Space.parser
        |> Parser.keep (Parser.loop [] importLoopParser)


moduleNameParser : Parser c Error (SourcePosition.Located String)
moduleNameParser =
    SourcePosition.parser
        ( Variable.foreignUpper
            |> Parser.mapError VariableError
            |> Parser.map Variable.foreignVarToString
        )


parseExposingStatement : Parser c Error AST.Exposing
parseExposingStatement =
    Parser.succeed identity
        |> Parser.skip (Parser.token (Parser.Token { str = "exposing", expecting = ExpectedKeyword "exposing"}))
        |> Parser.skip Space.parser
        |> Parser.skip (Parser.chompIf (\c -> c == '(') (ExpectedChar '('))
        |> Parser.skip Space.parser
        |> Parser.keep
            (Parser.oneOf
                [ Parser.succeed AST.Open
                    |> Parser.skip (Parser.token (Parser.Token { str = "..", expecting = ExpectedKeyword ".."}))
                    |> Parser.skip Space.parser
                    |> Parser.skip (Parser.chompIf (\c -> c == ')') (ExpectedChar ')'))
                , Parser.succeed AST.Explicit
                    |> Parser.keep
                        (parseExposingValue
                            |> Parser.skip Space.parser
                            |> Parser.andThen
                                (\firstExposing ->
                                    Parser.loop [ firstExposing ] parseExposingArray
                                )
                        )
                ]
            )

    
parseExposingArray : Array AST.Exposed -> Parser c Error (Parser.Step (Array AST.Exposed) (Array AST.Exposed))
parseExposingArray exps =
    Parser.oneOf
        [ Parser.succeed (Parser.Done exps)
            |> Parser.skip (Parser.chompIf (\c -> c == ')') (ExpectedChar ')'))
        , Parser.succeed (\next -> Parser.Loop <| Array.pushLast next exps)
            |> Parser.skip (Parser.chompIf (\c -> c == ',') (ExpectedChar ','))
            |> Parser.skip Space.parser
            |> Parser.keep parseExposingValue
            |> Parser.skip Space.parser
        ]


parseExposingValue : Parser c Error AST.Exposed
parseExposingValue =
    Parser.oneOf
        [ Parser.succeed AST.ExposedLower
            |> Parser.keep
                (SourcePosition.parser Variable.lowerCase
                    |> Parser.mapError VariableError
                )
        , Parser.succeed (\name privacy -> AST.ExposedUpper { name = name, privacy = privacy })
            |> Parser.keep
                (SourcePosition.parser Variable.upperCase
                    |> Parser.mapError VariableError
                )
            |> Parser.skip Space.parser
            |> Parser.keep
                (Parser.oneOf
                    [ Parser.succeed AST.Public
                        |> Parser.skip (Parser.chompIf (\c -> c == '(') (ExpectedChar '('))
                        |> Parser.skip Space.parser
                        |> Parser.skip (Parser.token (Parser.Token { str = "..", expecting = ExpectedKeyword ".."}))
                        |> Parser.skip Space.parser
                        |> Parser.skip (Parser.chompIf (\c -> c == ')') (ExpectedChar ')'))
                    , Parser.succeed AST.Private
                    ]
                )
        , Parser.succeed AST.ExposedOperator
            |> Parser.skip (Parser.chompIf (\c -> c == '(') (ExpectedChar '('))
            |> Parser.keep
                (SourcePosition.parser Operator.parser
                    |> Parser.mapError OperatorError
                )
            |> Parser.skip (Parser.chompIf (\c -> c == ')') (ExpectedChar ')'))
        ]


importLoopParser
    : Array (SourcePosition.Located AST.Import)
    -> Parser c Error (Parser.Step (Array (SourcePosition.Located  AST.Import)) (Array (SourcePosition.Located  AST.Import)))
importLoopParser imps =
    Parser.oneOf
        [ Parser.succeed
            (\moduleName ->
                SourcePosition.at
                    { moduleName.start | col = 1 }
                    moduleName.end
                    { module_ = moduleName
                    , alias = Nothing
                    , expose = AST.Explicit []
                    }
            )
            |> Parser.skip (Parser.token (Parser.Token { str = "import", expecting = ExpectedKeyword "import"}))
            |> Parser.skip Space.parser
            |> Parser.keep moduleNameParser
            |> Parser.skip Space.parser
            |> Parser.andThen
                (\baseImport ->
                    Parser.oneOf
                        [ Parser.succeed
                            (\alias ->
                                { baseImport
                                    | end = alias.end
                                    , value =
                                        { baseImport.value
                                            | alias = Just alias.value
                                        }
                                }
                            )
                            |> Parser.skip (Parser.token (Parser.Token { str = "as", expecting = ExpectedKeyword "as" }))
                            |> Parser.skip Space.parser
                            |> Parser.keep moduleNameParser
                            |> Parser.skip Space.parser
                        , Parser.succeed baseImport
                        ]
                )
            |> Parser.andThen
                (\importWithAlias ->
                    Parser.succeed
                        (\expose endPos ->
                            { importWithAlias
                                | end = endPos
                                , value =
                                    { importWithAlias.value
                                        | expose = expose
                                    }
                            }
                        )
                        |> Parser.keep
                            (Parser.oneOf
                                [ parseExposingStatement
                                , Parser.succeed (AST.Explicit [])
                                ]
                            )
                        |> Parser.keep Parser.getPosition
                        |> Parser.skip Space.parser
                )
            |> Parser.map
                (\finalImport ->
                    Parser.Loop <|
                        Array.pushLast finalImport imps
                )
        , Parser.succeed (Parser.Done imps)
        ]
