module Parse.Module exposing
    ( Error (..)
    , parser
    )


import Parser.Advanced as Parser exposing (Parser)
import AST.Source as AST
import SourcePosition
import Parse.Space as Space
import Parse.Variable as Variable
import Parse.Operator as Operator
import Parse.Declaration as Declaration
import Parse.Number as Number


type Error
    = ExpectedKeyword String
    | ExpectedChar Char
    | VariableError Variable.Error
    | OperatorError Operator.Error
    | ExpectedIntPrecedence


parser : Parser c Error AST.Module
parser =
    Parser.succeed
        (\name exports docs imports binops ->
            { name = name
            , exports = exports
            , docs = docs
            , imports = imports
            , values = []
            , unions = []
            , aliases = []
            , binops = binops
            , effects = AST.NoEffects
            }
        )
        |> Parser.skip (Parser.token (Parser.Token { str = "module", expecting = ExpectedKeyword "module"}))
        |> Parser.skip Space.parser
        |> Parser.keep moduleNameParser
        |> Parser.skip Space.parser
        |> Parser.keep parseExposingStatement
        |> Parser.skip Space.parser
        |> Parser.keep (Declaration.docParser ExpectedKeyword)
        |> Parser.skip Space.parser
        |> Parser.keep (Parser.loop [] importLoopParser)
        |> Parser.skip Space.parser
        |> Parser.keep (Parser.loop [] operatorLoopParser)


moduleNameParser : Parser c Error (SourcePosition.Located String)
moduleNameParser =
    SourcePosition.parser
        ( Variable.foreignUpper
            |> Parser.mapError VariableError
            |> Parser.map Variable.foreignVarToString
        )


parseExposingStatement : Parser c Error AST.Exposing
parseExposingStatement =
    Parser.succeed identity
        |> Parser.skip (Parser.token (Parser.Token { str = "exposing", expecting = ExpectedKeyword "exposing"}))
        |> Parser.skip Space.parser
        |> Parser.skip (Parser.chompIf (\c -> c == '(') (ExpectedChar '('))
        |> Parser.skip Space.parser
        |> Parser.keep
            (Parser.oneOf
                [ Parser.succeed AST.Open
                    |> Parser.skip (Parser.token (Parser.Token { str = "..", expecting = ExpectedKeyword ".."}))
                    |> Parser.skip Space.parser
                    |> Parser.skip (Parser.chompIf (\c -> c == ')') (ExpectedChar ')'))
                , Parser.succeed AST.Explicit
                    |> Parser.keep
                        (parseExposingValue
                            |> Parser.skip Space.parser
                            |> Parser.andThen
                                (\firstExposing ->
                                    Parser.loop [ firstExposing ] parseExposingArray
                                )
                        )
                ]
            )

    
parseExposingArray : Array AST.Exposed -> Parser c Error (Parser.Step (Array AST.Exposed) (Array AST.Exposed))
parseExposingArray exps =
    Parser.oneOf
        [ Parser.succeed (Parser.Done exps)
            |> Parser.skip (Parser.chompIf (\c -> c == ')') (ExpectedChar ')'))
        , Parser.succeed (\next -> Parser.Loop <| Array.pushLast next exps)
            |> Parser.skip (Parser.chompIf (\c -> c == ',') (ExpectedChar ','))
            |> Parser.skip Space.parser
            |> Parser.keep parseExposingValue
            |> Parser.skip Space.parser
        ]


parseExposingValue : Parser c Error AST.Exposed
parseExposingValue =
    Parser.oneOf
        [ Parser.succeed AST.ExposedLower
            |> Parser.keep
                (SourcePosition.parser Variable.lowerCase
                    |> Parser.mapError VariableError
                )
        , Parser.succeed (\name privacy -> AST.ExposedUpper { name = name, privacy = privacy })
            |> Parser.keep
                (SourcePosition.parser Variable.upperCase
                    |> Parser.mapError VariableError
                )
            |> Parser.skip Space.parser
            |> Parser.keep
                (Parser.oneOf
                    [ Parser.succeed AST.Public
                        |> Parser.skip (Parser.chompIf (\c -> c == '(') (ExpectedChar '('))
                        |> Parser.skip Space.parser
                        |> Parser.skip (Parser.token (Parser.Token { str = "..", expecting = ExpectedKeyword ".."}))
                        |> Parser.skip Space.parser
                        |> Parser.skip (Parser.chompIf (\c -> c == ')') (ExpectedChar ')'))
                    , Parser.succeed AST.Private
                    ]
                )
        , Parser.succeed AST.ExposedOperator
            |> Parser.skip (Parser.chompIf (\c -> c == '(') (ExpectedChar '('))
            |> Parser.keep
                (SourcePosition.parser Operator.parser
                    |> Parser.mapError OperatorError
                )
            |> Parser.skip (Parser.chompIf (\c -> c == ')') (ExpectedChar ')'))
        ]


parseAssociativity : Parser c Error AST.BinopAssociativity
parseAssociativity =
    Parser.oneOf
        [ Parser.succeed AST.OpALeft
            |> Parser.skip (Parser.token (Parser.Token { str = "left", expecting = ExpectedKeyword "left" }))
        , Parser.succeed AST.OpARight
            |> Parser.skip (Parser.token (Parser.Token { str = "right", expecting = ExpectedKeyword "right" }))
        , Parser.succeed AST.OpANone
            |> Parser.skip (Parser.token (Parser.Token { str = "non", expecting = ExpectedKeyword "non" }))
        ]


parsePrecedence : Parser c Error Int
parsePrecedence =
    Number.parser
        |> Parser.mapError (\_ -> ExpectedIntPrecedence)
        |> Parser.andThen
            (\outcome ->
                when outcome is
                    Number.Integer int ->
                        Parser.succeed int
                    _ ->
                        Parser.problem ExpectedIntPrecedence
            )


parseOperatorDeclaration : Parser c Error (SourcePosition.Located AST.Infix)
parseOperatorDeclaration =
    Parser.succeed (\start assoc prec op func end ->
        SourcePosition.at start end
            { fn = func.value
            , symbol = op.value
            , associativity = assoc
            , precedence = prec
            }
    )
        |> Parser.keep Parser.getPosition
        |> Parser.skip (Parser.token (Parser.Token { str = "infix", expecting = ExpectedKeyword "infix" }))
        |> Parser.skip Space.parser
        |> Parser.keep parseAssociativity
        |> Parser.skip Space.parser
        |> Parser.keep parsePrecedence
        |> Parser.skip Space.parser
        |> Parser.skip (Parser.chompIf (\c -> c == '(') (ExpectedChar '('))
        |> Parser.keep (SourcePosition.parser Operator.parser |> Parser.mapError OperatorError)
        |> Parser.skip (Parser.chompIf (\c -> c == ')') (ExpectedChar ')'))
        |> Parser.skip Space.parser
        |> Parser.skip (Parser.chompIf (\c -> c == '=') (ExpectedChar '='))
        |> Parser.skip Space.parser
        |> Parser.keep (SourcePosition.parser Variable.lowerCase |> Parser.mapError VariableError)
        |> Parser.keep Parser.getPosition


importLoopParser
    : Array (SourcePosition.Located AST.Import)
    -> Parser c Error (Parser.Step (Array (SourcePosition.Located  AST.Import)) (Array (SourcePosition.Located  AST.Import)))
importLoopParser imps =
    Parser.oneOf
        [ Parser.succeed
            (\moduleName ->
                SourcePosition.at
                    { moduleName.start | col = 1 }
                    moduleName.end
                    { module_ = moduleName
                    , alias = Nothing
                    , expose = AST.Explicit []
                    }
            )
            |> Parser.skip (Parser.token (Parser.Token { str = "import", expecting = ExpectedKeyword "import"}))
            |> Parser.skip Space.parser
            |> Parser.keep moduleNameParser
            |> Parser.skip Space.parser
            |> Parser.andThen
                (\baseImport ->
                    Parser.oneOf
                        [ Parser.succeed
                            (\alias ->
                                { baseImport
                                    | end = alias.end
                                    , value =
                                        { baseImport.value
                                            | alias = Just alias.value
                                        }
                                }
                            )
                            |> Parser.skip (Parser.token (Parser.Token { str = "as", expecting = ExpectedKeyword "as" }))
                            |> Parser.skip Space.parser
                            |> Parser.keep moduleNameParser
                            |> Parser.skip Space.parser
                        , Parser.succeed baseImport
                        ]
                )
            |> Parser.andThen
                (\importWithAlias ->
                    Parser.succeed
                        (\expose endPos ->
                            { importWithAlias
                                | end = endPos
                                , value =
                                    { importWithAlias.value
                                        | expose = expose
                                    }
                            }
                        )
                        |> Parser.keep
                            (Parser.oneOf
                                [ parseExposingStatement
                                , Parser.succeed (AST.Explicit [])
                                ]
                            )
                        |> Parser.keep Parser.getPosition
                        |> Parser.skip Space.parser
                )
            |> Parser.map
                (\finalImport ->
                    Parser.Loop <|
                        Array.pushLast finalImport imps
                )
        , Parser.succeed (Parser.Done imps)
        ]


operatorLoopParser
    : Array (SourcePosition.Located AST.Infix)
    -> Parser c Error (Parser.Step (Array (SourcePosition.Located AST.Infix)) (Array (SourcePosition.Located AST.Infix)))
operatorLoopParser ops =
    Parser.oneOf
        [ Parser.succeed
            (\op ->
                Parser.Loop <|
                    Array.pushLast op ops
            )
            |> Parser.keep parseOperatorDeclaration
            |> Parser.skip Space.parser
        , Parser.succeed (Parser.Done ops)
        ]
