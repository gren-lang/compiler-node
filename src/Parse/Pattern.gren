module Parse.Pattern exposing
    ( Error (..)
    , parser
    )


import Parser.Advanced as Parser exposing (Parser)
import AST.Source as AST
import SourcePosition
import Parse.Number as Number
import Parse.String as String
import Parse.Space as Space
import Parse.Variable as Variable
import Parse.Number as Number


type Error
    = ExpectedChar Char
    | ExpectedKeyword String
    | VariableError Variable.Error
    | NumberError Number.Error
    | FloatNotSupported
    | StringError String.Error


parser : Parser c Error AST.Pattern
parser =
    Parser.succeed (\start expr end -> SourcePosition.at start end expr)
        |> Parser.keep Parser.getPosition
        |> Parser.keep
            ( Parser.oneOf
                [ Parser.succeed (\name -> AST.PAnything name)
                    |> Parser.skip (Parser.chompIf (\c -> c == '_') (ExpectedChar '_'))
                    |> Parser.keep
                        (Parser.oneOf
                            [ lowerCaseVariable
                            , Parser.succeed ""
                            ]
                        )
                , lowerCaseVariable
                    |> Parser.map AST.PVar
                , Parser.succeed (\start var end arg -> { ctor = SourcePosition.at start end var, arg = arg })
                    |> Parser.keep Parser.getPosition
                    |> Parser.keep Variable.foreignUpper
                    |> Parser.mapError VariableError
                    |> Parser.keep Parser.getPosition
                    |> Parser.skip Space.parser
                    |> Parser.keep
                        (Parser.oneOf
                            [ Parser.lazy (\_ -> parser)
                                |> Parser.map Just
                            , Parser.succeed Nothing
                            ]
                        )
                    |> Parser.map
                        (\{ ctor = { start, end, value }, arg } ->
                            when value is
                                Variable.Unqualified ctor ->
                                    AST.PCtor
                                        { name = SourcePosition.at start end ctor
                                        , arg = arg
                                        }

                                Variable.Qualified { module_, name  } ->
                                    AST.PCtorQual
                                        { varRegion = { start = start, end = end }
                                        , module_ = module_
                                        , name = name
                                        , arg = arg
                                        }
                        )
                , Number.parser
                    |> Parser.mapError NumberError
                    |> Parser.andThen
                        (\num ->
                            when num is
                                Number.Integer int ->
                                    Parser.succeed <| AST.PInt { isHex = False, value = int }

                                Number.Hex int ->
                                    Parser.succeed <| AST.PInt { isHex = True, value = int }

                                Number.FloatingPoint _ ->
                                    Parser.problem FloatNotSupported
                        )
                , String.string
                    |> Parser.mapError StringError
                    |> Parser.map AST.PStr
                , String.char
                    |> Parser.mapError StringError
                    |> Parser.map AST.PChr
                ]
            )
        |> Parser.keep Parser.getPosition
        |> Parser.skip Space.parser


lowerCaseVariable : Parser c Error String
lowerCaseVariable =
    Variable.lowerCase
        |> Parser.mapError VariableError
