module Parse.String exposing
    ( Error (..)
    , char
    , string
    )


import Parser.Advanced as Parser exposing (Parser)
import Parse.Number as Number


type Error
    = ExpectedQuote
    | ExpectedChar
    | ExpectedEscapeChar String
    | ExpectedUnicodeOpening
    | ExpectedValidUnicode
    | ExpectedUnicodeClosing
    | ExpectedNewline


char : Parser c Error Char
char =
    Parser.succeed identity
        |> Parser.skip (Parser.symbol charQuote)
        |> Parser.keep coreParser
        |> Parser.skip (Parser.symbol charQuote)


coreParser : Parser c Error Char
coreParser =
    Parser.oneOf
        [ Parser.chompIf (\c -> c == '\\') ExpectedChar
            |> Parser.andThen
                (\_ ->
                    Parser.oneOf
                        [ Parser.chompIf (\c -> c == 'n') ExpectedChar
                            |> Parser.map (\_ -> '\n')
                        , Parser.chompIf (\c -> c == 'r') ExpectedChar
                            |> Parser.map (\_ -> '\r')
                        , Parser.chompIf (\c -> c == 't') ExpectedChar
                            |> Parser.map (\_ -> '\t')
                        , Parser.chompIf (\c -> c == '\\') ExpectedChar
                            |> Parser.map (\_ -> '\\')
                        , Parser.chompIf (\c -> c == '\'') ExpectedChar
                            |> Parser.map (\_ -> '\'')
                        , Parser.chompIf (\c -> c == '\"') ExpectedChar
                            |> Parser.map (\_ -> '\"')
                        , Parser.succeed identity
                            |> Parser.skip (Parser.symbol unicodeOpening)
                            |> Parser.keep (Number.hexParser ExpectedValidUnicode)
                            |> Parser.skip (Parser.chompIf (\c -> c == '}') ExpectedUnicodeClosing)
                            |> Parser.andThen
                                (\num ->
                                    let
                                        character =
                                            Char.fromCode num
                                    in
                                    -- Check if char is valid (replacement character)
                                    if character == '\u{FFFD}' then
                                        Parser.problem ExpectedValidUnicode

                                    else
                                        Parser.succeed character
                                )
                        , Parser.chompIf (\_ -> True)  ExpectedChar
                            |> Parser.getChompedString
                            |> Parser.andThen (Parser.problem << ExpectedEscapeChar)
                        ]
                )
        , Parser.chompIf (\_ -> True) ExpectedChar
            |> Parser.getChompedString
            |> Parser.andThen
                (\str ->
                    when String.popFirst str is
                        Nothing ->
                            Parser.problem ExpectedChar

                        Just { first = c } ->
                            Parser.succeed c
                )
        ]


charQuote : Parser.Token Error
charQuote =
    Parser.Token { str = "\'", expecting = ExpectedQuote }


singleLineStrQuote : Parser.Token Error
singleLineStrQuote =
    Parser.Token { str = "\"", expecting = ExpectedQuote }


multiLineStrQuote : Parser.Token Error
multiLineStrQuote =
    Parser.Token { str = "\"\"\"", expecting = ExpectedQuote }


unicodeOpening : Parser.Token Error
unicodeOpening =
    Parser.Token { str = "u{", expecting = ExpectedUnicodeOpening }


crlf : Parser.Token Error
crlf =
    Parser.Token { str = "\r\n", expecting = ExpectedNewline }


string : Parser c Error String
string =
    Parser.oneOf
        [ Parser.succeed identity
            |> Parser.skip (Parser.symbol multiLineStrQuote)
            |> Parser.skip
                (Parser.oneOf
                    [ Parser.chompIf (\c -> c == '\n') ExpectedNewline
                    , Parser.symbol crlf
                    ]
                )
            |> Parser.keep (Parser.loop "" (innerSingleLineString multiLineStrQuote))
            |> Parser.map String.trimRight
        , Parser.succeed identity
            |> Parser.skip (Parser.symbol singleLineStrQuote)
            |> Parser.keep (Parser.loop "" (innerSingleLineString singleLineStrQuote))
        ]


innerSingleLineString : Parser.Token Error -> String -> Parser c Error (Parser.Step String String)
innerSingleLineString endToken str =
    Parser.oneOf
        [ Parser.succeed {}
            |> Parser.skip (Parser.symbol endToken)
            |> Parser.map (\_ -> Parser.Done str)
        , Parser.succeed (\_ -> Parser.Loop (String.pushLast '\n' str))
            |> Parser.keep (Parser.symbol crlf)
        , Parser.succeed (\chr -> Parser.Loop (String.pushLast chr str))
            |> Parser.keep coreParser
        ]
