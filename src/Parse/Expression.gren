module Parse.Expression exposing
    ( Error (..)
    , parser
    )


import Parser.Advanced as Parser exposing (Parser)
import AST.Source as AST
import SourcePosition
import Parse.Number as Number
import Parse.String as String
import Parse.Space as Space
import Parse.Variable as Variable


type Error
    = ExpectedChar Char
    | VariableError Variable.Error
    | NumberError Number.Error
    | StringError String.Error
    | WildcardAttempt
    | ExpectedLowerVariable AST.Expression


parser : Parser c Error AST.Expression
parser =
    Parser.oneOf
        [ possiblyNegativeTerm
        ]


possiblyNegativeTerm : Parser c Error AST.Expression
possiblyNegativeTerm =
    Parser.oneOf
        [ Parser.succeed (\start expr end -> SourcePosition.at start end (AST.Negate expr))
            |> Parser.keep Parser.getPosition
            |> Parser.skip (Parser.chompIf (\c -> c == '-') (ExpectedChar '-'))
            |> Parser.keep term
            |> Parser.keep Parser.getPosition
        , term
        ]


term : Parser c Error AST.Expression
term =
    Parser.succeed (\start expr end -> SourcePosition.at start end expr)
        |> Parser.keep Parser.getPosition
        |> Parser.keep
            ( Parser.oneOf
                [ lowerCaseVariable
                    |> Parser.map (\name -> AST.Var { name = name, varType = AST.LowVar })
                , Variable.upperCase
                    |> Parser.mapError VariableError
                    |> Parser.map (\name -> AST.Var { name = name, varType = AST.CapVar })
                , Number.parser
                    |> Parser.mapError NumberError
                    |> Parser.map AST.NumberLiteral
                , String.char
                    |> Parser.mapError StringError
                    |> Parser.map AST.CharLiteral
                , String.string
                    |> Parser.mapError StringError
                    |> Parser.map AST.StringLiteral
                , arrayParser
                    |> Parser.map AST.ArrayLiteral
                , recordParser
                , Parser.succeed AST.Accessor
                    |> Parser.skip (Parser.chompIf (\c -> c == '.') (ExpectedChar '.'))
                    |> Parser.keep lowerCaseVariable
                , Parser.succeed identity
                    |> Parser.skip (Parser.chompIf (\c -> c == '_') (ExpectedChar '_'))
                    |> Parser.keep lowerCaseVariable
                    |> Parser.andThen
                        (\_ -> Parser.problem WildcardAttempt)
                ]
            )
        |> Parser.keep Parser.getPosition
        |> Parser.andThen
            (\expr ->
                when expr.value is
                    AST.Var { varType = AST.LowVar } ->
                        accessible expr

                    _ ->
                        Parser.succeed expr
            )


lowerCaseVariable : Parser c Error String
lowerCaseVariable =
    Variable.lowerCase
        |> Parser.mapError VariableError


accessible : AST.Expression -> Parser c Error AST.Expression
accessible currentExpression =
    Parser.oneOf
        [ Parser.succeed
            (\start name end ->
                SourcePosition.at
                    start
                    end
                    (AST.Access
                        { accessor = name
                        , expression = currentExpression
                        }
                    )
            )
            |> Parser.skip (Parser.chompIf (\c -> c == '.') (ExpectedChar '.'))
            |> Parser.keep Parser.getPosition
            |> Parser.keep lowerCaseVariable
            |> Parser.keep Parser.getPosition
            |> Parser.andThen accessible
        , Parser.succeed currentExpression
        ]


-- ARRAY


arrayParser : Parser c Error (Array AST.Expression)
arrayParser =
    Parser.succeed identity
        |> Parser.skip (Parser.chompIf (\c -> c == '[') (ExpectedChar '['))
        |> Parser.skip Space.parser
        |> Parser.keep
            (Parser.oneOf
                [ Parser.succeed []
                    |> Parser.skip (Parser.chompIf (\c -> c == ']') (ExpectedChar ']'))
                , Parser.lazy (\_ -> parser)
                    |> Parser.andThen
                        (\firstElement ->
                            Parser.succeed identity
                                |> Parser.skip Space.parser
                                |> Parser.keep (Parser.loop [ firstElement ] innerArrayParser)
                        )
                ]
            )


innerArrayParser : Array AST.Expression -> Parser c Error (Parser.Step (Array AST.Expression) (Array AST.Expression))
innerArrayParser array =
    Parser.oneOf
        [ Parser.succeed (Parser.Done array)
            |> Parser.skip (Parser.chompIf (\c -> c == ']') (ExpectedChar ']'))
        , Parser.succeed (\expr -> Parser.Loop (Array.pushLast expr array))
            |> Parser.skip (Parser.chompIf (\c -> c == ',') (ExpectedChar ','))
            |> Parser.skip Space.parser
            |> Parser.keep (Parser.lazy (\_ -> parser))
            |> Parser.skip Space.parser
        ]


-- RECORD


recordParser : Parser c Error AST.Expression_
recordParser =
    Parser.succeed identity
        |> Parser.skip (Parser.chompIf (\c -> c == '{') (ExpectedChar '{'))
        |> Parser.skip Space.parser
        |> Parser.keep
            (Parser.oneOf
                [ Parser.succeed (AST.Record [])
                    |> Parser.skip (Parser.chompIf (\c -> c == '}') (ExpectedChar '}'))
                , Parser.succeed identity
                    |> Parser.keep (Parser.lazy (\_ -> parser))
                    |> Parser.skip Space.parser
                    |> Parser.andThen
                        (\firstVarName ->
                            Parser.oneOf
                                [ Parser.succeed identity
                                    |> Parser.skip (Parser.chompIf (\c -> c == '|') (ExpectedChar '|'))
                                    |> Parser.skip Space.parser
                                    |> Parser.keep recordFieldParser
                                    |> Parser.andThen
                                        (\firstPair ->
                                            Parser.succeed
                                                (\fields ->
                                                    AST.Update
                                                        { record = firstVarName
                                                        , newValues = fields
                                                        }
                                                )
                                                |> Parser.skip Space.parser
                                                |> Parser.keep (Parser.loop [ firstPair ] innerRecordParser)
                                        )
                                , Parser.succeed identity
                                    |> Parser.skip (Parser.chompIf (\c -> c == '=') (ExpectedChar '='))
                                    |> Parser.skip Space.parser
                                    |> Parser.keep (Parser.lazy (\_ -> parser))
                                    |> Parser.skip Space.parser
                                    |> Parser.andThen
                                        (\value ->
                                            when firstVarName.value is
                                                AST.Var { name, varType = AST.LowVar } ->
                                                    let
                                                        locatedField =
                                                            SourcePosition.at firstVarName.start firstVarName.end name
                                                    in
                                                    Parser.succeed AST.Record
                                                        |> Parser.skip Space.parser
                                                        |> Parser.keep
                                                            (Parser.loop
                                                                [ { field = locatedField, value = value } ]
                                                                innerRecordParser
                                                            )

                                                _ ->
                                                    Parser.problem (ExpectedLowerVariable firstVarName)
                                        )
                                ]
                        )
                ]
            )


recordFieldParser : Parser c Error AST.RecordField
recordFieldParser =
    Parser.succeed
        (\fieldStart field fieldEnd value ->
            { field = SourcePosition.at fieldStart fieldEnd field
            , value = value
            }
        )
        |> Parser.keep Parser.getPosition
        |> Parser.keep lowerCaseVariable
        |> Parser.keep Parser.getPosition
        |> Parser.skip Space.parser
        |> Parser.skip (Parser.chompIf (\c -> c == '=') (ExpectedChar '='))
        |> Parser.skip Space.parser
        |> Parser.keep (Parser.lazy (\_ -> parser))


innerRecordParser : Array AST.RecordField -> Parser c Error (Parser.Step (Array AST.RecordField) (Array AST.RecordField))
innerRecordParser array =
    Parser.oneOf
        [ Parser.succeed (Parser.Done array)
            |> Parser.skip (Parser.chompIf (\c -> c == '}') (ExpectedChar '}'))
        , Parser.succeed (\expr -> Parser.Loop (Array.pushLast expr array))
            |> Parser.skip (Parser.chompIf (\c -> c == ',') (ExpectedChar ','))
            |> Parser.skip Space.parser
            |> Parser.keep recordFieldParser
            |> Parser.skip Space.parser
        ]
