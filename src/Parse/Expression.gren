module Parse.Expression exposing
    ( Error (..)
    , parser
    )


import Parser.Advanced as Parser exposing (Parser)
import AST.Source as AST
import SourcePosition
import Parse.Number as Number
import Parse.String as String
import Parse.Space as Space
import Parse.Variable as Variable


type Error
    = ExpectedChar Char
    | VariableError Variable.Error
    | NumberError Number.Error
    | StringError String.Error
    | WildcardAttempt


parser : Parser c Error AST.Expression
parser =
    Parser.oneOf
        [ possiblyNegativeTerm
        ]


possiblyNegativeTerm : Parser c Error AST.Expression
possiblyNegativeTerm =
    Parser.oneOf
        [ Parser.succeed (\start expr end -> SourcePosition.at start end (AST.Negate expr))
            |> Parser.keep Parser.getPosition
            |> Parser.skip (Parser.chompIf (\c -> c == '-') (ExpectedChar '-'))
            |> Parser.keep term
            |> Parser.keep Parser.getPosition
        , term
        ]


term : Parser c Error AST.Expression
term =
    Parser.succeed (\start expr end -> SourcePosition.at start end expr)
        |> Parser.keep Parser.getPosition
        |> Parser.keep
            ( Parser.oneOf
                [ lowerCaseVariable
                    |> Parser.map (\name -> AST.Var { name = name, varType = AST.LowVar })
                , Variable.upperCase
                    |> Parser.mapError VariableError
                    |> Parser.map (\name -> AST.Var { name = name, varType = AST.CapVar })
                , Number.parser
                    |> Parser.mapError NumberError
                    |> Parser.map AST.NumberLiteral
                , String.char
                    |> Parser.mapError StringError
                    |> Parser.map AST.CharLiteral
                , String.string
                    |> Parser.mapError StringError
                    |> Parser.map AST.StringLiteral
                , arrayParser
                    |> Parser.map AST.ArrayLiteral
                , Parser.succeed AST.Accessor
                    |> Parser.skip (Parser.chompIf (\c -> c == '.') (ExpectedChar '.'))
                    |> Parser.keep lowerCaseVariable
                , Parser.succeed identity
                    |> Parser.skip (Parser.chompIf (\c -> c == '_') (ExpectedChar '_'))
                    |> Parser.keep lowerCaseVariable
                    |> Parser.andThen
                        (\_ -> Parser.problem WildcardAttempt)
                ]
            )
        |> Parser.keep Parser.getPosition
        |> Parser.andThen
            (\expr ->
                when expr.value is
                    AST.Var { varType = AST.LowVar } ->
                        accessible expr

                    _ ->
                        Parser.succeed expr
            )


lowerCaseVariable : Parser c Error String
lowerCaseVariable =
    Variable.lowerCase
        |> Parser.mapError VariableError


accessible : AST.Expression -> Parser c Error AST.Expression
accessible currentExpression =
    Parser.oneOf
        [ Parser.succeed
            (\start name end ->
                SourcePosition.at
                    start
                    end
                    (AST.Access
                        { accessor = name
                        , expression = currentExpression
                        }
                    )
            )
            |> Parser.skip (Parser.chompIf (\c -> c == '.') (ExpectedChar '.'))
            |> Parser.keep Parser.getPosition
            |> Parser.keep lowerCaseVariable
            |> Parser.keep Parser.getPosition
            |> Parser.andThen accessible
        , Parser.succeed currentExpression
        ]


-- ARRAY


arrayParser : Parser c Error (Array AST.Expression)
arrayParser =
    Parser.succeed identity
        |> Parser.skip (Parser.chompIf (\c -> c == '[') (ExpectedChar '['))
        |> Parser.skip Space.parser
        |> Parser.keep
            (Parser.oneOf
                [ Parser.succeed []
                    |> Parser.skip (Parser.chompIf (\c -> c == ']') (ExpectedChar ']'))
                , Parser.lazy (\_ -> parser)
                    |> Parser.andThen
                        (\firstElement ->
                            Parser.succeed identity
                                |> Parser.skip Space.parser
                                |> Parser.keep (Parser.loop [ firstElement ] innerArrayParser)
                        )
                ]
            )


innerArrayParser : Array AST.Expression -> Parser c Error (Parser.Step (Array AST.Expression) (Array AST.Expression))
innerArrayParser array =
    Parser.oneOf
        [ Parser.succeed (Parser.Done array)
            |> Parser.skip (Parser.chompIf (\c -> c == ']') (ExpectedChar ']'))
        , Parser.succeed (\expr -> Parser.Loop (Array.pushLast expr array))
            |> Parser.skip (Parser.chompIf (\c -> c == ',') (ExpectedChar ','))
            |> Parser.skip Space.parser
            |> Parser.keep (Parser.lazy (\_ -> parser))
            |> Parser.skip Space.parser
        ]
