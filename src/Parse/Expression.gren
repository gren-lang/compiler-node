module Parse.Expression exposing
    ( Error (..)
    , parser
    )


import Parser.Advanced as Parser exposing (Parser)
import AST.Source as AST
import SourcePosition
import Parse.Number as Number
import Parse.String as String
import Parse.Space as Space
import Parse.Variable as Variable
import Parse.Pattern as Pattern
import Parse.Type as Type


type Error
    = ExpectedChar Char
    | ExpectedKeyword String
    | VariableError Variable.Error
    | NumberError Number.Error
    | StringError String.Error
    | PatternError Pattern.Error
    | TypeError Type.Error
    | WildcardAttempt
    | ExpectedLowerVariable AST.Expression
    | NameMismatch { first : String, second : String }
    | IndentError


parser : Parser c Error AST.Expression
parser =
    Parser.oneOf
        [ ifParser
        , whenParser
        , letParser
        , function
        , possiblyNegativeTerm
            |> Parser.andThen
                (\firstTerm ->
                    Parser.succeed
                        (\args ->
                            if Array.isEmpty args then
                                firstTerm

                            else
                                let
                                    end =
                                        Array.last args
                                            |> Maybe.map .end
                                            |> Maybe.withDefault firstTerm.end
                                in
                                SourcePosition.at
                                    firstTerm.start
                                    end
                                    (AST.Call { fn = firstTerm, args = args })
                        )
                    |> Parser.skip Space.parser
                    |> Parser.keep (Parser.withIndent firstTerm.start.col (Parser.loop [] argOrOperatorLoop))
                )
        ]


argOrOperatorLoop : Array AST.Expression -> Parser c Error (Parser.Step (Array AST.Expression) (Array AST.Expression))
argOrOperatorLoop args =
    Parser.oneOf
        [ Parser.succeed (\arg -> Parser.Loop <| Array.pushLast arg args)
            |> Parser.skip (Parser.mapError (\_ -> IndentError) Space.checkIndent)
            |> Parser.keep possiblyNegativeTerm
            |> Parser.skip Space.parser
        , Parser.succeed (Parser.Done args)
        ]


-- LET


letParser : Parser c Error AST.Expression
letParser =
    Parser.succeed
        (\start firstDef defs body end ->
            SourcePosition.at
                start
                end
                (AST.Let
                    { defs = Array.pushFirst firstDef defs
                    , body = body
                    }
                )
        )
        |> Parser.keep Parser.getPosition
        |> Parser.skip (Parser.keyword (Parser.Token { str = "let", expecting = ExpectedKeyword "let" }))
        |> Parser.skip Space.parser
        |> Parser.keep letDefParser
        |> Parser.skip Space.parser
        |> Parser.keep (Parser.loop [] letDefLoopParser)
        |> Parser.skip Space.parser
        |> Parser.keep (Parser.lazy (\_ -> parser))
        |> Parser.keep Parser.getPosition


letDefParser : Parser c Error (SourcePosition.Located AST.Def)
letDefParser =
    Parser.oneOf
        [ letDefNamedParser
        , letDefDestructParser
        ]


letDefNamedParser : Parser c Error (SourcePosition.Located AST.Def)
letDefNamedParser =
    Parser.succeed (\nameStart name nameEnd -> SourcePosition.at nameStart nameEnd name )
        |> Parser.keep Parser.getPosition
        |> Parser.keep lowerCaseVariable
        |> Parser.keep Parser.getPosition
        |> Parser.skip Space.parser
        |> Parser.andThen
            (\var ->
                Parser.succeed
                    (\signature args body ->
                        let
                            bodyEnd =
                                body.end
                        in
                        SourcePosition.at
                            var.start
                            bodyEnd
                            (AST.Define
                                { name = var
                                , args = args
                                , body = body
                                , typeSignature = signature
                                }
                            )
                    )
                    |> Parser.keep
                        (Parser.oneOf
                            [ Parser.succeed Just
                                |> Parser.skip (Parser.chompIf (\c -> c == ':') (ExpectedChar ':'))
                                |> Parser.skip Space.parser
                                |> Parser.keep (Parser.mapError TypeError (Parser.withIndent var.start.col Type.expression))
                                |> Parser.skip
                                    ( lowerCaseVariable
                                        |> Parser.andThen
                                            (\var2 ->
                                                if var.value /= var2 then
                                                    Parser.problem <|
                                                        NameMismatch
                                                            { first = var.value
                                                            , second = var2
                                                            }

                                                else
                                                    Parser.succeed {}
                                            )
                                
                                    )
                                |> Parser.skip Space.parser
                            , Parser.succeed Nothing
                            ]
                        )
                    |> Parser.keep (Parser.loop [] (functionArgsParser "="))
                    |> Parser.skip Space.parser
                    |> Parser.keep (Parser.lazy (\_ -> parser))
            )


letDefDestructParser : Parser c Error (SourcePosition.Located AST.Def)
letDefDestructParser =
    Parser.succeed
        (\pattern body ->
            SourcePosition.at
                pattern.start
                body.end
                (AST.Destruct
                    { pattern = pattern
                    , body = body
                    }
                )
        )
        |> Parser.keep (Parser.mapError PatternError Pattern.parser)
        |> Parser.skip Space.parser
        |> Parser.skip (Parser.chompIf (\c -> c == '=') (ExpectedChar '='))
        |> Parser.skip Space.parser
        |> Parser.keep (Parser.lazy (\_ -> parser))


letDefLoopParser : Array (SourcePosition.Located AST.Def) -> Parser c Error (Parser.Step (Array (SourcePosition.Located AST.Def)) (Array (SourcePosition.Located AST.Def)))
letDefLoopParser defs =
    Parser.oneOf
        [ Parser.succeed (Parser.Done defs)
            |> Parser.skip (Parser.keyword (Parser.Token { str = "in", expecting = ExpectedKeyword "in" }))
        , Parser.succeed (\def -> Parser.Loop <| Array.pushLast def defs)
            |> Parser.keep letDefParser
            |> Parser.skip Space.parser
        ]


-- IF


ifParser : Parser c Error AST.Expression
ifParser =
    Parser.succeed (\startPos firstBranch -> { startPos = startPos, firstBranch = firstBranch })
        |> Parser.keep Parser.getPosition
        |> Parser.keep ifBranchParser
        |> Parser.andThen
            (\{ startPos, firstBranch } ->
                Parser.loop [ firstBranch ] (ifElseLoop startPos)
            )


ifBranchParser : Parser c Error AST.IfBranch
ifBranchParser =
    Parser.succeed (\test body -> { test = test, body = body })
        |> Parser.skip (Parser.keyword (Parser.Token { str = "if", expecting = ExpectedKeyword "if" }))
        |> Parser.skip Space.parser
        |> Parser.keep (Parser.lazy (\_ -> parser))
        |> Parser.skip Space.parser
        |> Parser.skip (Parser.keyword (Parser.Token { str = "then", expecting = ExpectedKeyword "then" }))
        |> Parser.skip Space.parser
        |> Parser.keep (Parser.lazy (\_ -> parser))
        |> Parser.skip Space.parser
        |> Parser.skip (Parser.keyword (Parser.Token { str = "else", expecting = ExpectedKeyword "else" }))
        |> Parser.skip Space.parser


ifElseLoop : { row : Int, col : Int } -> Array AST.IfBranch -> Parser c Error (Parser.Step (Array AST.IfBranch) AST.Expression)
ifElseLoop startPos branches =
    Parser.oneOf
        [ Parser.succeed (\branch -> Parser.Loop (Array.pushLast branch branches))
            |> Parser.keep ifBranchParser
        , Parser.succeed
            (\expr ->
                Parser.Done <|
                    SourcePosition.at
                        startPos
                        expr.end
                        (AST.If
                            { branches = branches
                            , elseBranch = expr
                            }
                        )
            )
            |> Parser.keep parser
            |> Parser.skip Space.parser
        ]


-- WHEN IS


whenParser : Parser c Error AST.Expression
whenParser =
    Parser.succeed (\start expr firstBranch -> { start = start, expr = expr, firstBranch = firstBranch })
        |> Parser.keep Parser.getPosition
        |> Parser.skip (Parser.keyword (Parser.Token { str = "when", expecting = ExpectedKeyword "when" }))
        |> Parser.skip Space.parser
        |> Parser.keep (Parser.lazy (\_ -> parser))
        |> Parser.skip Space.parser
        |> Parser.skip (Parser.keyword (Parser.Token { str = "is", expecting = ExpectedKeyword "is" }))
        |> Parser.skip Space.parser
        |> Parser.keep whenBranchParser
        |> Parser.andThen
            (\{ start, expr, firstBranch } ->
                Parser.loop [ firstBranch ] whenBranchLoopParser
                    |> Parser.map
                        (\branches ->
                            let
                                endLocation =
                                    Array.last branches
                                        |> Maybe.map .body
                                        |> Maybe.map .end
                                        |> Maybe.withDefault { row = 1, col = 1 }
                            in
                            SourcePosition.at
                                start
                                endLocation
                                (AST.When { expression = expr, branches = branches })
                        )
            )

whenBranchParser : Parser c Error AST.WhenBranch
whenBranchParser =
    Parser.succeed (\pattern body -> { pattern = pattern, body = body })
        |> Parser.keep (Parser.mapError PatternError Pattern.parser)
        |> Parser.skip Space.parser
        |> Parser.skip (Parser.keyword (Parser.Token { str = "->", expecting = ExpectedKeyword "->" }))
        |> Parser.skip Space.parser
        |> Parser.keep (Parser.lazy (\_ -> parser))
        |> Parser.skip Space.parser


whenBranchLoopParser : Array AST.WhenBranch -> Parser c Error (Parser.Step (Array AST.WhenBranch) (Array AST.WhenBranch))
whenBranchLoopParser branches =
    Parser.oneOf
        [ Parser.succeed (\branch -> Parser.Loop (Array.pushLast branch branches))
            |> Parser.keep whenBranchParser
        , Parser.succeed (Parser.Done branches)
        ]


-- FUNCTION


function : Parser c Error AST.Expression
function =
    Parser.succeed (\startPos firstArg -> { startPos = startPos, firstArg = firstArg })
        |> Parser.keep Parser.getPosition
        |> Parser.skip (Parser.chompIf (\c -> c == '\\') (ExpectedChar '\\'))
        |> Parser.skip Space.parser
        |> Parser.keep (Parser.mapError PatternError Pattern.parser)
        |> Parser.skip Space.parser
        |> Parser.andThen
            (\{ startPos, firstArg } ->
                Parser.succeed
                    (\args body ->
                        SourcePosition.at
                            startPos
                            body.end
                            (AST.Lambda
                                { patterns = args
                                , body = body
                                }
                            )
                    )
                    |> Parser.keep (Parser.loop [ firstArg ] (functionArgsParser "->"))
                    |> Parser.skip Space.parser
                    |> Parser.keep parser
                    |> Parser.skip Space.parser
            )


functionArgsParser : String -> Array AST.Pattern -> Parser c Error (Parser.Step (Array AST.Pattern) (Array AST.Pattern))
functionArgsParser terminator array =
    Parser.oneOf
        [ Parser.succeed (Parser.Done array)
            |> Parser.skip (Parser.symbol (Parser.Token { str = terminator, expecting = ExpectedKeyword terminator }))
        , Parser.succeed (\expr -> Parser.Loop (Array.pushLast expr array))
            |> Parser.keep (Parser.mapError PatternError Pattern.parser)
            |> Parser.skip Space.parser
        ]


-- TERM

possiblyNegativeTerm : Parser c Error AST.Expression
possiblyNegativeTerm =
    Parser.oneOf
        [ Parser.succeed (\start expr end -> SourcePosition.at start end (AST.Negate expr))
            |> Parser.keep Parser.getPosition
            |> Parser.skip (Parser.chompIf (\c -> c == '-') (ExpectedChar '-'))
            |> Parser.keep term
            |> Parser.keep Parser.getPosition
        , term
        ]


term : Parser c Error AST.Expression
term =
    Parser.succeed (\start expr end -> SourcePosition.at start end expr)
        |> Parser.keep Parser.getPosition
        |> Parser.keep
            ( Parser.oneOf
                [ lowerCaseVariable
                    |> Parser.map (\name -> AST.Var { name = name, varType = AST.LowVar })
                , Variable.upperCase
                    |> Parser.mapError VariableError
                    |> Parser.map (\name -> AST.Var { name = name, varType = AST.CapVar })
                , Number.parser
                    |> Parser.mapError NumberError
                    |> Parser.map AST.NumberLiteral
                , String.char
                    |> Parser.mapError StringError
                    |> Parser.map AST.CharLiteral
                , String.string
                    |> Parser.mapError StringError
                    |> Parser.map AST.StringLiteral
                , arrayParser
                    |> Parser.map AST.ArrayLiteral
                , recordParser
                , Parser.succeed AST.Accessor
                    |> Parser.skip (Parser.chompIf (\c -> c == '.') (ExpectedChar '.'))
                    |> Parser.keep lowerCaseVariable
                , Parser.succeed identity
                    |> Parser.skip (Parser.chompIf (\c -> c == '_') (ExpectedChar '_'))
                    |> Parser.keep lowerCaseVariable
                    |> Parser.andThen
                        (\_ -> Parser.problem WildcardAttempt)
                ]
            )
        |> Parser.keep Parser.getPosition
        |> Parser.andThen
            (\expr ->
                when expr.value is
                    AST.Var { varType = AST.LowVar } ->
                        accessible expr

                    _ ->
                        Parser.succeed expr
            )


lowerCaseVariable : Parser c Error String
lowerCaseVariable =
    Variable.lowerCase
        |> Parser.mapError VariableError


accessible : AST.Expression -> Parser c Error AST.Expression
accessible currentExpression =
    Parser.oneOf
        [ Parser.succeed
            (\start name end ->
                SourcePosition.at
                    start
                    end
                    (AST.Access
                        { accessor = name
                        , expression = currentExpression
                        }
                    )
            )
            |> Parser.skip (Parser.chompIf (\c -> c == '.') (ExpectedChar '.'))
            |> Parser.keep Parser.getPosition
            |> Parser.keep lowerCaseVariable
            |> Parser.keep Parser.getPosition
            |> Parser.andThen accessible
        , Parser.succeed currentExpression
        ]


-- ARRAY


arrayParser : Parser c Error (Array AST.Expression)
arrayParser =
    Parser.succeed identity
        |> Parser.skip (Parser.chompIf (\c -> c == '[') (ExpectedChar '['))
        |> Parser.skip Space.parser
        |> Parser.keep
            (Parser.oneOf
                [ Parser.succeed []
                    |> Parser.skip (Parser.chompIf (\c -> c == ']') (ExpectedChar ']'))
                , Parser.lazy (\_ -> parser)
                    |> Parser.andThen
                        (\firstElement ->
                            Parser.succeed identity
                                |> Parser.skip Space.parser
                                |> Parser.keep (Parser.loop [ firstElement ] innerArrayParser)
                        )
                ]
            )


innerArrayParser : Array AST.Expression -> Parser c Error (Parser.Step (Array AST.Expression) (Array AST.Expression))
innerArrayParser array =
    Parser.oneOf
        [ Parser.succeed (Parser.Done array)
            |> Parser.skip (Parser.chompIf (\c -> c == ']') (ExpectedChar ']'))
        , Parser.succeed (\expr -> Parser.Loop (Array.pushLast expr array))
            |> Parser.skip (Parser.chompIf (\c -> c == ',') (ExpectedChar ','))
            |> Parser.skip Space.parser
            |> Parser.keep (Parser.lazy (\_ -> parser))
            |> Parser.skip Space.parser
        ]


-- RECORD


recordParser : Parser c Error AST.Expression_
recordParser =
    Parser.succeed identity
        |> Parser.skip (Parser.chompIf (\c -> c == '{') (ExpectedChar '{'))
        |> Parser.skip Space.parser
        |> Parser.keep
            (Parser.oneOf
                [ Parser.succeed (AST.Record [])
                    |> Parser.skip (Parser.chompIf (\c -> c == '}') (ExpectedChar '}'))
                , Parser.succeed identity
                    |> Parser.keep (Parser.lazy (\_ -> parser))
                    |> Parser.skip Space.parser
                    |> Parser.andThen
                        (\firstVarName ->
                            Parser.oneOf
                                [ Parser.succeed identity
                                    |> Parser.skip (Parser.chompIf (\c -> c == '|') (ExpectedChar '|'))
                                    |> Parser.skip Space.parser
                                    |> Parser.keep recordFieldParser
                                    |> Parser.andThen
                                        (\firstPair ->
                                            Parser.succeed
                                                (\fields ->
                                                    AST.Update
                                                        { record = firstVarName
                                                        , newValues = fields
                                                        }
                                                )
                                                |> Parser.skip Space.parser
                                                |> Parser.keep (Parser.loop [ firstPair ] innerRecordParser)
                                        )
                                , Parser.succeed identity
                                    |> Parser.skip (Parser.chompIf (\c -> c == '=') (ExpectedChar '='))
                                    |> Parser.skip Space.parser
                                    |> Parser.keep (Parser.lazy (\_ -> parser))
                                    |> Parser.skip Space.parser
                                    |> Parser.andThen
                                        (\value ->
                                            when firstVarName.value is
                                                AST.Var { name, varType = AST.LowVar } ->
                                                    let
                                                        locatedField =
                                                            SourcePosition.at firstVarName.start firstVarName.end name
                                                    in
                                                    Parser.succeed AST.Record
                                                        |> Parser.skip Space.parser
                                                        |> Parser.keep
                                                            (Parser.loop
                                                                [ { field = locatedField, value = value } ]
                                                                innerRecordParser
                                                            )

                                                _ ->
                                                    Parser.problem (ExpectedLowerVariable firstVarName)
                                        )
                                ]
                        )
                ]
            )


recordFieldParser : Parser c Error AST.RecordField
recordFieldParser =
    Parser.succeed
        (\fieldStart field fieldEnd value ->
            { field = SourcePosition.at fieldStart fieldEnd field
            , value = value
            }
        )
        |> Parser.keep Parser.getPosition
        |> Parser.keep lowerCaseVariable
        |> Parser.keep Parser.getPosition
        |> Parser.skip Space.parser
        |> Parser.skip (Parser.chompIf (\c -> c == '=') (ExpectedChar '='))
        |> Parser.skip Space.parser
        |> Parser.keep (Parser.lazy (\_ -> parser))


innerRecordParser : Array AST.RecordField -> Parser c Error (Parser.Step (Array AST.RecordField) (Array AST.RecordField))
innerRecordParser array =
    Parser.oneOf
        [ Parser.succeed (Parser.Done array)
            |> Parser.skip (Parser.chompIf (\c -> c == '}') (ExpectedChar '}'))
        , Parser.succeed (\expr -> Parser.Loop (Array.pushLast expr array))
            |> Parser.skip (Parser.chompIf (\c -> c == ',') (ExpectedChar ','))
            |> Parser.skip Space.parser
            |> Parser.keep recordFieldParser
            |> Parser.skip Space.parser
        ]
