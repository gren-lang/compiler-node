module Parse.Number exposing
    ( Outcome (..)
    , Error (..)
    , parser
    )


import Parser.Advanced as Parser exposing (Parser)


type Outcome
    = Integer Int
    | FloatingPoint Float
    | Hex Int


type Error
    = NotANumber
    | LeadingZero
    | ExpectedInt
    | ExpectedHex


parser : Parser c Error Outcome
parser =
    Parser.oneOf
        [ Parser.succeed
            (\outcome ->
                when outcome is
                    Integer int ->
                        Integer (negate int)

                    FloatingPoint float ->
                        FloatingPoint (negate float)

                    Hex hex ->
                        Hex (negate hex)
            )
            |> Parser.skip (Parser.symbol negateSign)
            |> Parser.keep numParser
        , numParser
        ]
        |> Parser.andThen
            (\successCase ->
                Parser.oneOf
                    [ Parser.chompIf Char.isAlpha NotANumber
                        |> Parser.andThen (\_ -> Parser.problem NotANumber)
                    , Parser.succeed successCase
                    ]
            )


negateSign : Parser.Token Error
negateSign =
    Parser.Token { str = "-", expecting = NotANumber }


numParser : Parser c Error Outcome
numParser =
    Parser.oneOf
        [ Parser.chompIf (\c -> c == '0') NotANumber
            |> Parser.andThen
                (\_ ->
                    Parser.oneOf
                        [ Parser.chompIf (\c -> c == 'x') NotANumber
                            |> Parser.andThen (\_ -> hexParser)
                        , Parser.chompIf (\c -> c == '.') NotANumber
                            |> Parser.andThen (\_ -> fractalParser "0")
                        , Parser.chompIf Char.isDigit NotANumber
                            |> Parser.andThen (\_ -> Parser.problem LeadingZero)
                        , Parser.succeed (Integer 0)
                        ]
                )
        , Parser.chompIf Char.isDigit NotANumber
            |> Parser.skip (Parser.chompWhile Char.isDigit)
            |> Parser.getChompedString
            |> Parser.andThen
                (\str ->
                    when String.toInt str is
                        Nothing ->
                            Parser.problem NotANumber

                        Just num ->
                            Parser.oneOf
                                [ Parser.chompIf (\c -> c == '.') NotANumber
                                    |> Parser.andThen (\_ -> fractalParser str)
                                , Parser.succeed (Integer num)
                                ]
                )
        ]


fractalParser : String -> Parser c Error Outcome
fractalParser str =
    Parser.chompIf Char.isDigit ExpectedInt
        |> Parser.skip (Parser.chompWhile Char.isDigit)
        |> Parser.getChompedString
        |> Parser.andThen
            (\postDot ->
                when String.toFloat (str ++ "." ++ postDot) is
                    Nothing ->
                        Parser.problem NotANumber

                    Just float ->
                        Parser.succeed (FloatingPoint float)
            )

hexParser : Parser c Error Outcome
hexParser =
    Parser.chompIf Char.isHexDigit ExpectedHex
        |> Parser.skip (Parser.chompWhile Char.isHexDigit)
        |> Parser.getChompedString
        |> Parser.andThen
            (\hexString ->
                String.foldl hexFolder 0 hexString
                    |> Hex
                    |> Parser.succeed
            )


hexFolder : Char -> Int -> Int
hexFolder char acc =
    let
        charCode =
            Char.toCode char
    in
    if charCode >= 48 && charCode <= 57 then
        -- 0-9
        16 * acc + charCode - 48

    else if charCode >= 65 && charCode <= 70 then
        -- A-F
        16 * acc + 10 + charCode - 65

    else if charCode >= 97 && charCode <= 102 then
        -- a-f
        16 * acc + 10 + charCode - 97

    else
        acc
