module Parse.Declaration exposing
    ( Declaration
    , DeclarationValue (..)
    , Error (..)
    , parser
    )


import Parser.Advanced as Parser exposing (Parser)
import AST.Source as AST
import SourcePosition
import Parse.Space as Space
import Parse.Variable as Variable
import Parse.Pattern as Pattern
import Parse.Type as Type


type alias Declaration =
    { docs : Maybe (SourcePosition.Located String)
    , value : DeclarationValue
    }


type DeclarationValue
    = Alias AST.Alias
    | Union AST.Union


type Error
    = ExpectedKeyword String
    | ExpectedChar Char
    | VariableError Variable.Error
    | TypeError Type.Error


parser : Parser c Error Declaration
parser =
    Parser.succeed
        (\docs value ->
            { docs = docs
            , value = value
            }
        )
        |> Parser.keep
            (Parser.oneOf
                [ Parser.succeed
                    (\docStart doc docEnd ->
                        Just <|
                            SourcePosition.at docStart docEnd doc
                    )
                    |> Parser.keep Parser.getPosition
                    |> Parser.skip (Parser.token (Parser.Token { str = "{-|", expecting = ExpectedKeyword "{-|" }))
                    |> Parser.skip Space.parser
                    |> Parser.keep
                        (Parser.chompUntil (Parser.Token { str = "-}", expecting = ExpectedKeyword "-}" })
                            |> Parser.getChompedString
                            |> Parser.map (String.dropLast 2 >> String.trimRight)
                        )
                    |> Parser.keep Parser.getPosition
                    |> Parser.skip Space.parser
                , Parser.succeed Nothing
                ]
            )
        |> Parser.keep typeParser


typeParser : Parser c Error DeclarationValue
typeParser =
    Parser.succeed identity
        |> Parser.skip (Parser.token (Parser.Token { str = "type", expecting = ExpectedKeyword "type"}))
        |> Parser.skip Space.parser
        |> Parser.keep (Parser.oneOf [ aliasParser, unionParser ])


aliasParser : Parser c Error DeclarationValue
aliasParser =
    Parser.succeed
        (\nameStart name nameEnd vars tipe ->
            Alias
                { name = SourcePosition.at nameStart nameEnd name
                , vars = vars
                , type_ = tipe
                }
        )
        |> Parser.skip (Parser.token (Parser.Token { str = "alias", expecting = ExpectedKeyword "alias"}))
        |> Parser.skip Space.parser
        |> Parser.keep Parser.getPosition
        |> Parser.keep (Parser.mapError VariableError Variable.upperCase)
        |> Parser.keep Parser.getPosition
        |> Parser.skip Space.parser
        |> Parser.keep (Parser.loop [] typeArgLoopParser)
        |> Parser.skip Space.parser
        |> Parser.keep (Parser.mapError TypeError Type.expression)


typeArgLoopParser : Array (SourcePosition.Located String) -> Parser c Error (Parser.Step (Array (SourcePosition.Located String)) (Array (SourcePosition.Located String)))
typeArgLoopParser vars =
    Parser.oneOf
        [ Parser.succeed (Parser.Done vars)
            |> Parser.skip (Parser.chompIf (\c -> c == '=') (ExpectedChar '='))
        , Parser.succeed
            (\varStart var varEnd ->
                Parser.Loop <|
                    Array.pushLast (SourcePosition.at varStart varEnd var) vars
            )
            |> Parser.keep Parser.getPosition
            |> Parser.keep (Parser.mapError VariableError Variable.lowerCase)
            |> Parser.keep Parser.getPosition
            |> Parser.skip Space.parser
        ]


unionParser : Parser c Error DeclarationValue
unionParser =
    Parser.succeed
        (\nameStart name nameEnd vars variants ->
            Union
                { name = SourcePosition.at nameStart nameEnd name
                , vars = vars
                , variants = variants
                }
        )
        |> Parser.keep Parser.getPosition
        |> Parser.keep (Parser.mapError VariableError Variable.upperCase)
        |> Parser.keep Parser.getPosition
        |> Parser.skip Space.parser
        |> Parser.keep (Parser.loop [] typeArgLoopParser)
        |> Parser.skip Space.parser
        |> Parser.keep
            (variantParser
                |> Parser.andThen
                    (\firstVariant ->
                        (Parser.loop [ firstVariant ] variantLoopParser)
                    )
            )


variantParser : Parser c Error (SourcePosition.Located AST.UnionVariant)
variantParser =
    Parser.succeed
        (\nameStart name nameEnd payload ->
            let
                variantEnd =
                    payload
                        |> Maybe.map .end
                        |> Maybe.withDefault nameEnd
            in
            SourcePosition.at
                nameStart
                variantEnd
                { name = SourcePosition.at nameStart nameEnd name
                , payload = payload
                }
        )
        |> Parser.keep Parser.getPosition
        |> Parser.keep (Parser.mapError VariableError Variable.upperCase)
        |> Parser.keep Parser.getPosition
        |> Parser.skip Space.parser
        |> Parser.keep
            (Parser.oneOf
                [ Parser.succeed Just
                    |> Parser.keep (Parser.mapError TypeError Type.expression)
                , Parser.succeed Nothing
                ]
            )


variantLoopParser : Array (SourcePosition.Located AST.UnionVariant) -> Parser c Error (Parser.Step (Array (SourcePosition.Located AST.UnionVariant)) (Array (SourcePosition.Located AST.UnionVariant)))
variantLoopParser variants =
    Parser.oneOf
        [ Parser.succeed
            (\variant ->
                Parser.Loop <|
                    Array.pushLast variant variants
            )
            |> Parser.skip (Parser.chompIf (\c -> c == '|') (ExpectedChar '|'))
            |> Parser.skip Space.parser
            |> Parser.keep variantParser
        , Parser.succeed (Parser.Done variants)
        ]
